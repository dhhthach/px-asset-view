<!--
    Relative paths assume component is being run from inside an app or another component, where dependencies are flat
    siblings. When this component is run from its own repo (e.g. tests, examples), we assume the server is started with
    'gulp serve' (or similar server setup) to enable correct finding of bower dependencies for local runs.
-->
<link rel="import" href="../polymer/polymer.html" />
<link rel="import" href="../px-spinner/px-spinner.html"/>
<link rel="import" href="../px-vis/px-vis-d3.html"/>
<link rel="import" href="tree-behavior.html">
<link rel="import" href="node-viewer.html"/>

<link rel="import" href="css/px-asset-view-styles.html">


<!--
Dendrogram element. See the demo page (demo.html) for a working example.

#### Usage
Minimum:

    <px-asset-view></px-asset-view>

Advanced:

    <px-asset-view items-per-level='10'
                   data-source='{"name": "Home", "icon": "f015", "total": 10}'>
    </px-asset-view>

### Code on your page

Define how your data will come in using these methods:

    window.addEventListener('WebComponentsReady', function() {
        var dendrogramDOM = document.querySelector('px-asset-view');
        dendrogramDOM.addEventListener('px-asset-view-children-request', function(e) {
            dendrogramDOM.appendChildren(e.detail.parent, childrenData);
        });
    });


@element px-dendrogram
@blurb Context browser element
@homepage index.html
@demo index.html
-->

<dom-module id="px-asset-view">

  <link rel="stylesheet" href="bower_components/font-awesome/css/font-awesome.min.css">

  <template>
    <style include="px-asset-view-styles"></style>
    <div id="container">
      <div id="graph">
        <svg width$="[[_computeSVGWidth(_width, _margin.right, _margin.left)]]"
             height$="[[_computeSVGHeight(_height, _margin.top, _margin.bottom)]]">
          <g transform$="[[_computeTransform(_margin)]]"></g>
        </svg>
      </div>
      <!--<div id="export_btn" on-click="_exportJsonData">Export JSON</div>-->
    </div>
  </template>
</dom-module>

<script>

  Polymer({

    is: 'px-asset-view',

    properties: {
      isTemplate: {
        type: Boolean,
        value: true
      }
    },

    behaviors: [MyBehaviors.TreeBehavior],

    _editNode: function(node) {

      var nodeViewer = document.createElement('node-viewer');
      nodeViewer.nodeData = node;

      Polymer.dom(this.$.container).appendChild(nodeViewer);

      nodeViewer.addEventListener('save', (function(e) {
        this._updateRawJSON(e.detail);
        this._updateTree(e.detail);
      }).bind(this));

      nodeViewer.addEventListener('close', (function() {
        Polymer.dom(this.$.container).removeChild(nodeViewer);
      }).bind(this));

    },

    _createNode: function(node) {

      var nodeViewer = document.createElement('node-viewer');
      nodeViewer.isNew = true;

      Polymer.dom(this.$.container).appendChild(nodeViewer);

      nodeViewer.addEventListener('save', (function(e) {
        this._updateHierarchy(node, [e.detail.data]);
        this._updateRawJSON(node, e.detail.data);
        this._updateTree(node);
      }).bind(this));

      nodeViewer.addEventListener('close', (function() {
        Polymer.dom(this.$.container).removeChild(nodeViewer);
      }).bind(this));

    },

    retrieveJsonData: function() {
//      return JSON.parse(JSON.stringify(this.dataSource, ['name', 'attributes', 'children']));
      var nodes = [];
      var queue = [this.dataSource];
      var n;
      while (queue.length > 0) {
        n = queue.pop();
        nodes.push({
          name : n.name,
          attributes: n.attributes,
          parent: n.parent
        });
        if (n.children) {
          queue = queue.concat(n.children.map(function(e) {
            e.parent = n.name;
            return e;
          }));
        }
      }

      return {
        nodes: nodes
      }
    },

    _updateRawJSON: function(node, newNodeData) {
      var queue = [this.dataSource];
      var n;
      while (queue.length > 0) {
        n = queue.pop();
        if (n.id === node.data.id) {
          if (newNodeData) {
            n.children = n.children || [];
            n.children.push(newNodeData);
          } else {
            n.name = node.data.name;
            n.attributes = node.data.attributes;
          }
          break;
        }
        if (n.children) {
          queue = queue.concat(n.children);
        }
      }
    },

    _deleteNodes: function(node) {
      var parent = node.parent;
      var children;
      if (parent) {
        children = parent.children || parent._children;
        var index = children.findIndex(function(e) {
          return e.data.id === node.data.id;
        });
        children.splice(index, 1);
        parent.data.total -= 1;
        if (children.length === 0) {
          parent.children ? (parent.children = null) : (parent._children = null);
        }
        this._updateRawJSONonDelete(parent, node);
        this._updateTree(parent);
      } else {
        alert('Can not delete root node');
      }
    },

    _updateRawJSONonDelete: function(parentNode, removedNode) {
      var queue = [this.dataSource];
      var n;
      while (queue.length > 0) {
        n = queue.pop();
        if (n.name === parentNode.data.name) {
          n.children = n.children.filter(function(e) {
            return e.name != removedNode.data.name;
          });
          break;
        }
        if (n.children) {
          queue = queue.concat(n.children);
        }
      }
    }

  });
</script>